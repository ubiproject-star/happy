{
  "version": 3,
  "sources": ["../../react-error-boundary/lib/context/ErrorBoundaryContext.ts", "../../react-error-boundary/lib/components/ErrorBoundary.tsx", "../../react-error-boundary/lib/utils/isErrorBoundaryContext.ts", "../../react-error-boundary/lib/utils/assertErrorBoundaryContext.ts", "../../react-error-boundary/lib/hooks/useErrorBoundary.ts", "../../react-error-boundary/lib/utils/getErrorMessage.ts", "../../react-error-boundary/lib/utils/withErrorBoundary.ts"],
  "sourcesContent": ["import { createContext } from \"react\";\n\nexport type ErrorBoundaryContextType = {\n  didCatch: boolean;\n  error: unknown | null;\n  resetErrorBoundary: (...args: unknown[]) => void;\n};\n\nexport const ErrorBoundaryContext =\n  createContext<ErrorBoundaryContextType | null>(null);\n", "import { Component, createElement, type ErrorInfo } from \"react\";\nimport { ErrorBoundaryContext } from \"../context/ErrorBoundaryContext\";\nimport type { ErrorBoundaryProps, FallbackProps } from \"../types\";\n\nconst isDevelopment = import.meta.env.DEV;\n\ntype ErrorBoundaryState =\n  | {\n      didCatch: true;\n      error: unknown;\n    }\n  | {\n      didCatch: false;\n      error: null;\n    };\n\nconst initialState: ErrorBoundaryState = {\n  didCatch: false,\n  error: null,\n};\n\n/**\n * A reusable React [error boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary) component.\n * Wrap this component around other React components to \"catch\" errors and render a fallback UI.\n *\n * This package is built on top of React [error boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary),\n * so it has all of the advantages and constraints of that API.\n * This means that it can't catch errors during:\n * - Server side rendering</li>\n * - Event handlers\n * - Asynchronous code (including effects)\n *\n * ℹ️ The component provides several ways to render a fallback: `fallback`, `fallbackRender`, and `FallbackComponent`.\n * Refer to the documentation to determine which is best for your application.\n *\n * ℹ️ This is a **client component**. You can only pass props to it that are serializeable or use it in files that have a `\"use client\";` directive.\n */\nexport class ErrorBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    return { didCatch: true, error };\n  }\n\n  resetErrorBoundary(...args: unknown[]) {\n    const { error } = this.state;\n\n    if (error !== null) {\n      this.props.onReset?.({\n        args,\n        reason: \"imperative-api\",\n      });\n\n      this.setState(initialState);\n    }\n  }\n\n  componentDidCatch(error: unknown, info: ErrorInfo) {\n    this.props.onError?.(error, info);\n  }\n\n  componentDidUpdate(\n    prevProps: ErrorBoundaryProps,\n    prevState: ErrorBoundaryState,\n  ) {\n    const { didCatch } = this.state;\n    const { resetKeys } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (\n      didCatch &&\n      prevState.error !== null &&\n      hasArrayChanged(prevProps.resetKeys, resetKeys)\n    ) {\n      this.props.onReset?.({\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\",\n      });\n\n      this.setState(initialState);\n    }\n  }\n\n  render() {\n    const { children, fallbackRender, FallbackComponent, fallback } =\n      this.props;\n    const { didCatch, error } = this.state;\n\n    let childToRender = children;\n\n    if (didCatch) {\n      const props: FallbackProps = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary,\n      };\n\n      if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else if (fallback !== undefined) {\n        childToRender = fallback;\n      } else {\n        if (isDevelopment) {\n          console.error(\n            \"react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop\",\n          );\n        }\n\n        throw error;\n      }\n    }\n\n    return createElement(\n      ErrorBoundaryContext.Provider,\n      {\n        value: {\n          didCatch,\n          error,\n          resetErrorBoundary: this.resetErrorBoundary,\n        },\n      },\n      childToRender,\n    );\n  }\n}\n\nfunction hasArrayChanged(a: unknown[] = [], b: unknown[] = []) {\n  return (\n    a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]))\n  );\n}\n", "import type { ErrorBoundaryContextType } from \"../context/ErrorBoundaryContext\";\n\nexport function isErrorBoundaryContext(\n  value: unknown,\n): value is ErrorBoundaryContextType {\n  return (\n    value !== null &&\n    typeof value === \"object\" &&\n    \"didCatch\" in value &&\n    typeof value.didCatch === \"boolean\" &&\n    \"error\" in value &&\n    \"resetErrorBoundary\" in value &&\n    typeof value.resetErrorBoundary === \"function\"\n  );\n}\n", "import type { ErrorBoundaryContextType } from \"../context/ErrorBoundaryContext\";\nimport { isErrorBoundaryContext } from \"./isErrorBoundaryContext\";\n\nexport function assertErrorBoundaryContext(\n  value: unknown,\n): asserts value is ErrorBoundaryContextType {\n  if (!isErrorBoundaryContext(value)) {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n}\n", "import { useContext, useMemo, useState } from \"react\";\nimport { ErrorBoundaryContext } from \"../context/ErrorBoundaryContext\";\nimport { assertErrorBoundaryContext } from \"../utils/assertErrorBoundaryContext\";\n\ntype UseErrorBoundaryState =\n  | { error: unknown; hasError: true }\n  | { error: null; hasError: false };\n\nexport type UseErrorBoundaryApi = {\n  error: unknown | null;\n  resetBoundary: () => void;\n  showBoundary: (error: unknown) => void;\n};\n\n/**\n * Convenience hook for imperatively showing or dismissing error boundaries.\n *\n * ⚠️ This hook must only be used within an `ErrorBoundary` subtree.\n */\nexport function useErrorBoundary(): {\n  /**\n   * The currently visible `Error` (if one has been thrown).\n   */\n  error: unknown | null;\n\n  /**\n   * Method to reset and retry the nearest active error boundary (if one is active).\n   */\n  resetBoundary: () => void;\n\n  /**\n   * Trigger the nearest error boundary to display the error provided.\n   *\n   * ℹ️ React only handles errors thrown during render or during component lifecycle methods (e.g. effects and did-mount/did-update).\n   * Errors thrown in event handlers, or after async code has run, will not be caught.\n   * This method is a way to imperatively trigger an error boundary during these phases.\n   */\n  showBoundary: (error: unknown) => void;\n} {\n  const context = useContext(ErrorBoundaryContext);\n\n  assertErrorBoundaryContext(context);\n\n  const { error, resetErrorBoundary } = context;\n\n  const [state, setState] = useState<UseErrorBoundaryState>({\n    error: null,\n    hasError: false,\n  });\n\n  const memoized = useMemo(\n    () => ({\n      error,\n      resetBoundary: () => {\n        resetErrorBoundary();\n        setState({ error: null, hasError: false });\n      },\n      showBoundary: (error: unknown) =>\n        setState({\n          error,\n          hasError: true,\n        }),\n    }),\n    [error, resetErrorBoundary],\n  );\n\n  if (state.hasError) {\n    throw state.error;\n  }\n\n  return memoized;\n}\n", "export function getErrorMessage(thrown: unknown): string | undefined {\n  switch (typeof thrown) {\n    case \"object\": {\n      if (\n        thrown !== null &&\n        \"message\" in thrown &&\n        typeof thrown.message === \"string\"\n      ) {\n        return thrown.message;\n      }\n      break;\n    }\n    case \"string\": {\n      return thrown;\n    }\n  }\n}\n", "import {\n  createElement,\n  forwardRef,\n  type ComponentClass,\n  type ComponentType,\n} from \"react\";\nimport { ErrorBoundary } from \"../components/ErrorBoundary\";\nimport type { ErrorBoundaryProps } from \"../types\";\n\nexport function withErrorBoundary<\n  Type extends ComponentClass<unknown>,\n  Props extends object,\n>(Component: ComponentType<Props>, errorBoundaryProps: ErrorBoundaryProps) {\n  const Wrapped = forwardRef<InstanceType<Type>, Props>((props, ref) =>\n    createElement(\n      ErrorBoundary,\n      errorBoundaryProps,\n      createElement(Component, { ...props, ref } as Props),\n    ),\n  );\n\n  // Format for display in DevTools\n  const name = Component.displayName || Component.name || \"Unknown\";\n  Wrapped.displayName = `withErrorBoundary(${name})`;\n\n  return Wrapped;\n}\n"],
  "mappings": "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",
  "names": ["ErrorBoundaryContext", "createContext", "initialState", "ErrorBoundary", "Component", "props", "error", "args", "info", "prevProps", "prevState", "didCatch", "resetKeys", "hasArrayChanged", "children", "fallbackRender", "FallbackComponent", "fallback", "childToRender", "createElement", "a", "b", "item", "index", "isErrorBoundaryContext", "value", "assertErrorBoundaryContext", "useErrorBoundary", "context", "useContext", "resetErrorBoundary", "state", "setState", "useState", "memoized", "useMemo", "getErrorMessage", "thrown", "withErrorBoundary", "errorBoundaryProps", "Wrapped", "forwardRef", "ref", "name"]
}
